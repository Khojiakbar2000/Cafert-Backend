<%- include('includes/header') %>

<!-- FontAwesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
  body {
    background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
    min-height: 100vh;
    margin: 0;
    font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
    overflow-x: hidden;
    cursor: grab;
  }
  
  body:active {
    cursor: grabbing;
  }
  
  .earth-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  
  #earth-canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }
  
  .content-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    pointer-events: none;
  }
  
  .brand-title {
    font-size: 4.5rem;
    font-weight: bold;
    letter-spacing: 3px;
    margin-bottom: 1rem;
    background: linear-gradient(-45deg, #DEB887, #CD853F, #D2691E, #8B4513, #DEB887);
    background-size: 400% 400%;
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    -webkit-text-fill-color: transparent;
    animation: gradient 4s ease infinite;
    text-align: center;
    text-shadow: 0 0 30px rgba(222, 184, 135, 0.5);
  }
  
  .brand-subtitle {
    font-size: 1.5rem;
    color: #bdc3c7;
    margin-bottom: 3rem;
    opacity: 0.9;
    text-align: center;
    text-shadow: 0 0 20px rgba(189, 195, 199, 0.3);
  }
  
  .stats-section {
    display: flex;
    justify-content: center;
    gap: 3rem;
    margin-top: 2rem;
    flex-wrap: wrap;
  }
  
  .stat-card {
    background: rgba(44, 62, 80, 0.8);
    border-radius: 20px;
    padding: 1.5rem 2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 150px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }
  
  .stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 40px rgba(0,0,0,0.4);
  }
  
  .stat-card i {
    font-size: 2.5rem;
    color: #DEB887;
    margin-bottom: 1rem;
    text-shadow: 0 0 20px rgba(222, 184, 135, 0.5);
  }
  
  .stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 10px rgba(255,255,255,0.3);
  }
  
  .stat-label {
    font-size: 1.1rem;
    color: #bdc3c7;
    margin-top: 0.5rem;
    text-align: center;
  }
  
  .controls-info {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(44, 62, 80, 0.8);
    border-radius: 10px;
    padding: 15px;
    color: #bdc3c7;
    font-size: 0.9rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    z-index: 20;
    pointer-events: none;
  }
  
  @keyframes gradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  
  @media (max-width: 768px) {
    .brand-title { font-size: 2.5rem; }
    .brand-subtitle { font-size: 1.2rem; }
    .stats-section { gap: 1.5rem; }
    .stat-card { padding: 1rem 1.5rem; min-width: 120px; }
    .stat-card i { font-size: 2rem; }
    .stat-number { font-size: 1.5rem; }
    .controls-info { display: none; }
  }
</style>

<div class="earth-container">
  <canvas id="earth-canvas"></canvas>
  
  <div class="content-overlay">
    <h1 class="brand-title">Cafert Admin</h1>
    <p class="brand-subtitle">Global Coffee Management System</p>
    <div class="stats-section">
      <div class="stat-card">
        <i class="fas fa-coffee"></i>
        <span class="stat-number">150+</span>
        <span class="stat-label">Products</span>
      </div>
      <div class="stat-card">
        <i class="fas fa-users"></i>
        <span class="stat-number">1.2K</span>
        <span class="stat-label">Customers</span>
      </div>
      <div class="stat-card">
        <i class="fas fa-globe"></i>
        <span class="stat-number">25+</span>
        <span class="stat-label">Countries</span>
      </div>
      <div class="stat-card">
        <i class="fas fa-chart-line"></i>
        <span class="stat-number">98%</span>
        <span class="stat-label">Satisfaction</span>
      </div>
    </div>
  </div>
  
  <div class="controls-info">
    <div>üñ±Ô∏è Drag to rotate</div>
    <div>üîç Scroll to zoom</div>
    <div>üì± Touch to interact</div>
  </div>
</div>

<script>
  // Highly Interactive Earth Animation
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('earth-canvas');
    const renderer = new THREE.WebGLRenderer({ 
      canvas: canvas, 
      alpha: true, 
      antialias: true,
      powerPreference: "high-performance"
    });
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    
    // Initial camera position
    camera.position.z = 20;

    // Create Earth with high-quality texture
    const geometry = new THREE.SphereGeometry(8, 128, 128);
    const textureLoader = new THREE.TextureLoader();
    
    // Load Earth texture
    const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
    const material = new THREE.MeshPhongMaterial({ 
      map: earthTexture, 
      shininess: 25,
      specular: 0x333333
    });
    
    const earth = new THREE.Mesh(geometry, material);
    scene.add(earth);

    // Enhanced lighting setup
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(20, 20, 20);
    
    const rimLight = new THREE.DirectionalLight(0xDEB887, 0.4);
    rimLight.position.set(-15, -15, -15);

    scene.add(ambientLight);
    scene.add(directionalLight);
    scene.add(rimLight);

    // Create massive star field
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({ 
      color: 0xffffff, 
      size: 0.15,
      transparent: true,
      opacity: 0.8
    });
    
    const starsVertices = [];
    for (let i = 0; i < 5000; i++) {
      starsVertices.push(
        Math.random() * 4000 - 2000,
        Math.random() * 4000 - 2000,
        Math.random() * 4000 - 2000
      );
    }
    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Add atmosphere glow
    const atmosphereGeometry = new THREE.SphereGeometry(8.3, 64, 64);
    const atmosphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x4a90e2,
      transparent: true,
      opacity: 0.1
    });
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    scene.add(atmosphere);

    // Interactive controls
    let isMouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;
    let currentRotationX = 0;
    let currentRotationY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Mouse events
    canvas.addEventListener('mousedown', (event) => {
      isMouseDown = true;
      isDragging = false;
      dragStartX = event.clientX;
      dragStartY = event.clientY;
      document.body.style.cursor = 'grabbing';
    });
    
    canvas.addEventListener('mousemove', (event) => {
      if (isMouseDown) {
        const deltaX = event.clientX - dragStartX;
        const deltaY = event.clientY - dragStartY;
        
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
          isDragging = true;
        }
        
        if (isDragging) {
          targetRotationY += deltaX * 0.01;
          targetRotationX += deltaY * 0.01;
          
          // Limit vertical rotation
          targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
          
          dragStartX = event.clientX;
          dragStartY = event.clientY;
        }
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      isMouseDown = false;
      isDragging = false;
      document.body.style.cursor = 'grab';
    });
    
    canvas.addEventListener('mouseleave', () => {
      isMouseDown = false;
      isDragging = false;
      document.body.style.cursor = 'grab';
    });

    // Touch events for mobile
    canvas.addEventListener('touchstart', (event) => {
      event.preventDefault();
      isMouseDown = true;
      isDragging = false;
      const touch = event.touches[0];
      dragStartX = touch.clientX;
      dragStartY = touch.clientY;
    });
    
    canvas.addEventListener('touchmove', (event) => {
      event.preventDefault();
      if (isMouseDown && event.touches.length === 1) {
        const touch = event.touches[0];
        const deltaX = touch.clientX - dragStartX;
        const deltaY = touch.clientY - dragStartY;
        
        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
          isDragging = true;
        }
        
        if (isDragging) {
          targetRotationY += deltaX * 0.01;
          targetRotationX += deltaY * 0.01;
          
          // Limit vertical rotation
          targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
          
          dragStartX = touch.clientX;
          dragStartY = touch.clientY;
        }
      }
    });
    
    canvas.addEventListener('touchend', () => {
      isMouseDown = false;
      isDragging = false;
    });

    // Zoom functionality
    let targetZoom = 20;
    let currentZoom = 20;
    
    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const zoomSpeed = 0.1;
      targetZoom += event.deltaY * zoomSpeed;
      targetZoom = Math.max(10, Math.min(50, targetZoom)); // Limit zoom range
    });

    // Pinch zoom for mobile
    let initialDistance = 0;
    let initialZoom = 0;
    
    canvas.addEventListener('touchstart', (event) => {
      if (event.touches.length === 2) {
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        initialDistance = Math.sqrt(
          Math.pow(touch2.clientX - touch1.clientX, 2) +
          Math.pow(touch2.clientY - touch1.clientY, 2)
        );
        initialZoom = targetZoom;
      }
    });
    
    canvas.addEventListener('touchmove', (event) => {
      if (event.touches.length === 2) {
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        const currentDistance = Math.sqrt(
          Math.pow(touch2.clientX - touch1.clientX, 2) +
          Math.pow(touch2.clientY - touch1.clientY, 2)
        );
        
        const zoomDelta = (initialDistance - currentDistance) * 0.01;
        targetZoom = initialZoom + zoomDelta;
        targetZoom = Math.max(10, Math.min(50, targetZoom));
      }
    });

    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      
      // Smooth rotation interpolation
      currentRotationX += (targetRotationX - currentRotationX) * 0.1;
      currentRotationY += (targetRotationY - currentRotationY) * 0.1;
      
      earth.rotation.x = currentRotationX;
      earth.rotation.y = currentRotationY;
      
      // Smooth zoom interpolation
      currentZoom += (targetZoom - currentZoom) * 0.1;
      camera.position.z = currentZoom;
      
      // Auto-rotation when not interacting
      if (!isDragging && !isMouseDown) {
        targetRotationY += 0.002;
      }
      
      // Stars rotation
      stars.rotation.y += 0.0002;
      stars.rotation.x += 0.0001;
      
      // Atmosphere pulse
      atmosphere.material.opacity = 0.1 + Math.sin(time * 2) * 0.05;
      
      renderer.render(scene, camera);
    }
    animate();

    // Responsive handling
    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // Performance optimization
    let isVisible = true;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    });
    observer.observe(canvas);
  });
</script>

<%- include('includes/footer') %>
